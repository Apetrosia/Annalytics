import { Mapper } from "./mapper";
import { Signal0 } from "../../core/signaling";
import { ColorArray } from "../../core/types";
import { color2rgba, encode_rgba } from "../../core/util/color";
import { to_big_endian } from "../../core/util/platform";
import { is_NDArray, Uint32NDArray } from "../../core/util/ndarray";
export function convert_to_uint32_color(color) {
    return encode_rgba(color2rgba(color));
}
export function convert_to_uint32_palette(palette) {
    const new_palette = new Uint32Array(palette.length);
    for (let i = 0, end = palette.length; i < end; i++) {
        new_palette[i] = convert_to_uint32_color(palette[i]);
    }
    return new_palette;
}
export class ColorMapper extends Mapper {
    static __name__ = "ColorMapper";
    metrics_change;
    constructor(attrs) {
        super(attrs);
    }
    initialize() {
        super.initialize();
        this.metrics_change = new Signal0(this, "metrics_change");
    }
    static {
        this.define(({ Color, List }) => ({
            palette: [List(Color)],
            nan_color: [Color, "gray"],
        }));
    }
    v_compute(xs) {
        const values = new Uint32Array(xs.length);
        this._v_compute(xs, values, convert_to_uint32_palette(this.palette), this._colors(convert_to_uint32_color));
        return new Uint32NDArray(values);
    }
    get rgba_mapper() {
        const self = this;
        const palette = convert_to_uint32_palette(this.palette);
        const colors = this._colors(convert_to_uint32_color);
        return {
            v_compute(xs) {
                const length_divisor = is_NDArray(xs) && xs.dimension == 3 ? xs.shape[2] : 1;
                const values = new ColorArray(xs.length / length_divisor);
                self._v_compute(xs, values, palette, colors);
                return new Uint8ClampedArray(to_big_endian(values).buffer);
            },
        };
    }
    _colors(conv) {
        return { nan_color: conv(this.nan_color) };
    }
}
//# sourceMappingURL=color_mapper.js.map