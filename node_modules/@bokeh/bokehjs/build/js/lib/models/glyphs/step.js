import { XYGlyph, XYGlyphView } from "./xy_glyph";
import { generic_line_scalar_legend } from "./utils";
import * as mixins from "../../core/property_mixins";
import { StepMode } from "../../core/enums";
import { unreachable } from "../../core/util/assert";
export class StepView extends XYGlyphView {
    static __name__ = "StepView";
    async load_glglyph() {
        const { StepGL } = await import("./webgl/step");
        return StepGL;
    }
    _paint(ctx, indices, data) {
        const npoints = indices.length;
        if (npoints < 2) {
            return;
        }
        let indices_consecutive = [];
        for (let i = 0; i < indices.length; i++) {
            if (i == 0) {
                indices_consecutive.push(indices[i]);
            }
            else if ((indices[i] - 1) != indices[i - 1]) {
                this._paint_consecutive(ctx, indices_consecutive, data);
                indices_consecutive = [indices[i]];
            }
            else {
                indices_consecutive.push(indices[i]);
                if (i + 1 == indices.length) {
                    this._paint_consecutive(ctx, indices_consecutive, data);
                }
            }
        }
    }
    _paint_consecutive(ctx, indices, data) {
        const { sx, sy } = { ...this, ...data };
        const mode = this.model.mode;
        this.visuals.line.set_value(ctx);
        let drawing = false;
        let prev_finite = false;
        const i = indices[0];
        let is_finite = isFinite(sx[i] + sy[i]);
        if (mode == "center") {
            drawing = this._render_xy(ctx, drawing, is_finite ? sx[i] : NaN, sy[i]);
        }
        for (let k = 0; k < indices.length; k++) {
            const i = indices[k];
            const next_finite = isFinite(sx[i + 1] + sy[i + 1]) && indices[k + 1] == i + 1;
            switch (mode) {
                case "before":
                    drawing = this._render_xy(ctx, drawing, is_finite ? sx[i] : NaN, sy[i]);
                    if (i < sx.length - 1) {
                        drawing = this._render_xy(ctx, drawing, is_finite && next_finite ? sx[i] : NaN, sy[i + 1]);
                    }
                    break;
                case "after":
                    drawing = this._render_xy(ctx, drawing, is_finite ? sx[i] : NaN, sy[i]);
                    if (i < sx.length - 1) {
                        drawing = this._render_xy(ctx, drawing, is_finite && next_finite ? sx[i + 1] : NaN, sy[i]);
                    }
                    break;
                case "center":
                    if (is_finite && next_finite) {
                        const midx = (sx[i] + sx[i + 1]) / 2;
                        drawing = this._render_xy(ctx, drawing, midx, sy[i]);
                        drawing = this._render_xy(ctx, drawing, midx, sy[i + 1]);
                    }
                    else {
                        if (prev_finite) {
                            drawing = this._render_xy(ctx, drawing, is_finite ? sx[i] : NaN, sy[i]);
                        }
                        drawing = this._render_xy(ctx, drawing, next_finite ? sx[i + 1] : NaN, sy[i + 1]);
                    }
                    break;
                default:
                    unreachable();
            }
            prev_finite = is_finite;
            is_finite = next_finite;
        }
        if (drawing) {
            const i = indices[indices.length - 1];
            if (this._render_xy(ctx, drawing, is_finite ? sx[i] : NaN, sy[i])) {
                ctx.stroke();
            }
        }
    }
    _render_xy(ctx, drawing, x, y) {
        if (isFinite(x + y)) {
            if (drawing) {
                // Continue with current line
                ctx.lineTo(x, y);
            }
            else {
                // Start new line
                ctx.beginPath();
                ctx.moveTo(x, y);
                drawing = true;
            }
        }
        else if (drawing) {
            // End current line
            ctx.stroke();
            drawing = false;
        }
        return drawing;
    }
    draw_legend_for_index(ctx, bbox, _index) {
        generic_line_scalar_legend(this.visuals, ctx, bbox);
    }
}
export class Step extends XYGlyph {
    static __name__ = "Step";
    constructor(attrs) {
        super(attrs);
    }
    static {
        this.prototype.default_view = StepView;
        this.mixins(mixins.LineScalar);
        this.define(() => ({
            mode: [StepMode, "before"],
        }));
    }
}
//# sourceMappingURL=step.js.map